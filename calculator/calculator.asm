DATA SEGMENT
divisors DW 10000, 1000, 100, 10, 1
results DB 0,0,0,0,0,"$"    ;存放五位数ASCII
DATA ENDS

STACK SEGMENT
STACK ENDS

CODE SEGMENT
ASSUME CS:CODE
MAIN PROC FAR
MOV AX,DATA
MOV DS,AX

NOW:
MOV AX, 0
CALL INPUT

PUSH BX
;----------------
CMP AL,'+'
JZ PLUS
CMP AL,'-'
JZ MINUS
CMP AL,'*'
JZ BY
CMP AL,'/'
JZ DIVD

PLUS:
CALL INPUT
POP AX
ADD AX,BX
JMP NEXT

MINUS:
CALL INPUT
POP AX
CMP AX,BX
JL LESS
SUB AX,BX
JMP NEXT
LESS:
SUB AX,BX
NEG AX
PUSH AX
MOV DL,'-'
MOV AH,02H
INT 21H
POP AX
JMP NEXT

BY:
CALL INPUT
POP AX
MUL BX
JMP NEXT

DIVD:
CALL INPUT
POP AX
CMP AX,BX
JL LESS2
DIV BX
JMP NEXT
LESS2:
PUSH AX
MOV DL,30H
MOV AH,02H
INT 21H
MOV DL,'~'
MOV AH,02H
INT 21H
POP AX
JMP NEXT

NEXT:
CALL OUTPUT
JMP NOW
MOV AH,4CH
INT 21H
RET
MAIN ENDP

INPUT PROC NEAR
MOV BX,0
NUM:
MOV AH,1
INT 21H
CMP AL,'C'
JZ CLEAR
CMP AL,'+'
JZ EXIT
CMP AL,'-'
JZ EXIT
CMP AL,'*'
JZ EXIT
CMP AL,'/'
JZ EXIT

SUB AL,30H
JL EXIT
CMP AL,9
JG EXIT
CBW
XCHG AX,BX
MOV CX,10
MUL CX
XCHG AX,BX
ADD BX,AX
JMP NUM

CLEAR:
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
MOV AX,0
MOV BX,0
JMP NUM

EXIT:RET
INPUT ENDP
OUTPUT PROC NEAR
mov si, offset divisors
mov di, offset results
mov cx,5
CAL:
mov dx,0
div word ptr [si]
add al,30H
mov byte ptr [di],al
inc di
add si,2
mov ax,dx
LOOP CAL
mov cx,4
mov di, offset results
NZ:
cmp byte ptr [di],'0'
jne print
inc di
loop NZ
print:
mov dx,di
MOV AH,9
INT 21H
RET
OUTPUT ENDP
CODE ENDS
END MAIN
